ron-iam
---

参考：[Go语言项目开发实战](https://time.geekbang.org/column/intro/100079601)

https://github.com/marmotedu/iam

[《Go 语言项目开发实战》课程补充](https://github.com/marmotedu/geekbang-go)



## 1 概述



Go应用的安全大体上分为2类：

- **服务自身的安全**：为了保证服务的安全，需要禁止非法用户访问服务。这可以通过服务器层面和软件层面来解决。

  **服务器层面**可以通过**物理隔离、网络隔离、防火墙**等技术从底层保证服务的安全性，

  **软件层面**可以通过**HTTPS、用户认证**等手段来加强服务的安全性。

  服务器层面一般由运维团队来保障，软件层面则需要开发者来保障。

- 服务资源的安全：服务内有很多资源，为了避免非法访问，开发者要避免 UserA 访问到 UserB 的资源，也即需要对资源进行授权。通常，可以通过**资源授权系统**来对资源进行授权。

对访问进行认证，对资源进行授权。

将认证和授权的功能实现升级为IAM系统。

### 1.1 IAM系统是什么？

IAM（Identity and Access Management，身份识别与访问管理）系统是用 Go 语言编写的一个 Web 服务，用于给第三方用户提供访问控制服务。

解决的问题是：**在特定的条件下，谁能够/不能够对哪些资源做哪些操作**（Who is able to do what on something given some context），也即完成资源授权功能。

![](images/image-20240714001854603.png)

1.  用户需要提供昵称、密码、邮箱、电话等信息注册并登录到IAM系统，这里是以用户名和密码作为唯一的身份标识来访问 IAM 系统，并且完成**认证**。
2.  因为访问IAM的资源授权接口是通过密钥（secretID/secretKey）的方式进行认证的，所以用户需要 IAM中创建属于自己的密钥资源。
3.  因为IAM通过授权策略完成授权，所以用户需要在IAM中创建**授权策略**。
4.  请求IAM提供的授权接口，IAM会根据用户的**请求内容和授权策略**来决定一个授权请求是否被允许。

在上面的流程中，IAM使用到了3种系统资源：用户（User）、密钥（Secret）和策略（Policy），映射到程序设计中就是3种RESTful资源：
•  ==用户（User）==：实现对用户的增、删、改、查、修改密码、批量修改等操作。
•  ==密钥（Secret）==：实现对密钥的增、删、改、查操作。
•  ==策略（Policy）==：实现对策略的增、删、改、查、批量删除操作。

### 1.2 IAM系统的架构

![](images/image-20240714002402893.png)

9大组件和3大数据库（Redis、MySQL和MongoDB）

![](images/image-20240714002555530.png)

![](images/image-20240714002618073.png)

#### 1️⃣通过使用流程理解架构

1. 创建平台资源。

用户通过 ==iam-webconsole==（RESTful API）或 ==iamctl==（sdk marmotedu-sdk-go）客户端请求 ==iam-apiserver== 提供的 RESTful API 接口完成用户、密钥、授权策略的增删改查，iam-apiserver 会将这些资源数据持久化存储在 MySQL 数据库中。而且，为了确保通信安全，客户端访问服务端都是通过 HTTPS 协议来访问的。

2. 请求 API 完成资源授权。

用户可以通过请求 ==iam-authz-server== 提供的 /v1/authz 接口进行**资源授权**，请求/v1/authz 接口需要通过密钥认证，认证通过后 /v1/authz 接口会查询授权策略，从而决定资源请求是否被允许。为了提高 /v1/authz 接口的性能，iam-authz-server 将密钥和策略信息缓存在内存中，以便实现快速查询。

那密钥和策略信息是如何实现缓存的呢？

首先，iam-authz-server 通过调用 iam-apiserver 提供的 gRPC 接口，将密钥和授权策略信息缓存到内存中。同时，为了使内存中的缓存信息和 iam-apiserver 中的信息保持一致，当 iam-apiserver 中有密钥或策略被更新时，iam-apiserver 会往特定的 Redis Channel（iam-authz-server 也会订阅该 Channel）中发送PolicyChanged 和 SecretChanged 消息。这样一来，当 iam-authz-server 监听到有新消息时就会获取并解析消息，根据消息内容判断是否需要重新调用 gRPC 接来获取密钥和授权策略信息，再更新到内存中。



3. 授权日志数据分析。

iam-authz-server 会将授权日志上报到 Redis 高速缓存中，然后 iam-pump 组件会异步消费这些授权日志，再把清理后的数据保存在 MongoDB 中，供运营系统 ==iam-operating-system== 查询。

> 注意：iam-authz-server 将授权日志保存在 Redis 高性能 key-value 数据库中，可以最大化减少写入延时。不保存在内存中是因为授权日志量我们没法预测，当授权日志量很大时，很可能会将内存耗尽，造成服务中断。

4. 运营平台授权数据展示。

iam-operating-system 是 IAM 的运营系统，它可以通过查询 MongoDB 获取并展示运营数据，比如某个用户的授权/失败次数、授权失败时的授权信息等。

此外，也可以通过 iam-operating-system 调用 iam-apiserver 服务来做些运营管理工作。比如，以上帝视角查看某个用户的授权策略供排障使用，或者调整用户可创建密钥的最大个数，再或者通过白名单的方式，让某个用户不受密钥个数限制的影响等等。



#### 2️⃣IAM软件架构模式

2种最常用的软件架构模式

##### 前后端分离架构

一般来说，运营系统的功能可多可少，对于一些具有复杂功能的运营系统，我们可以采用前后端分离的架构。其中，**前端负责页面的展示以及数据的加载和渲染，后端只负责返回前端需要的数据。**

IAM的运营系统 iam-operating-system

![](images/image-20240714003504732.png)

##### MVC架构

如果运营系统功能比较少，采用前后端分离框架的弊反而大于利，比如前后端分离要同时维护 2 个组件会导致部署更复杂，并且前后端分离将人员也分开了，这会增加一定程度的沟通成本。同时，因为代码中也需要实现前后端交互的逻辑，所以会引入一定的开发量。

![](images/image-20240714003714458.png)

## 2 环境准备：如何安装和配置一个基本的Go开发环境？

配置一个Go开发环境通过4步实现：

#### 2.1 Linux 服务器申请和配置



#### 2.2 依赖安装和配置



#### 2.3 Go编译环境安装和配置



ProtoBuf 编译环境安装：

- 安装protobuf的编译器 protoc

```sh
brew install protobuf

protoc --version
```

- 安装protoc-gen-go

> protoc 需要 protoc-gen-go 来完成 Go 语言的代码转换

```go
sudo go install github.com/golang/protobuf/protoc-gen-go@v1.5.2
```



#### 2.4 Go开发IDE安装和配置



## 3 项目部署：如何快速部署IAM系统？

了解 IAM 项目一个最直接有效的方式就是去部署和使用它。

### 下载iam项目代码



### 安装和配置数据库



### 安装和配置IAM系统



### 安装man文件



# 一、规范设计

## 4 规范设计（上）：项目开发杂乱无章，如何规范？

没有统一的规范，会造成一些问题：

- 代码风格不一
- 目录杂乱无章
- 接口不统一
- 错误码不规范

### 4.1 哪些地方需要制定规范

- 非编码类规范，主要包括开源规范、文档规范、版本规范、Commit 规范和发布规范。
- 编码类规范，则主要包括目录规范、代码规范、接口规范、日志规范和错误码规范。

![](images/image-20240718193907063.png)

### 4.2 开源规范

一个开源项目一定需要一个开源协议，开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。

#### 开源协议概述

常用6种开源协议：GPL、MPL、LGPL、Apache、BSD 和 MIT。

![](images/f7374fae0370466fbad9ccb6ef352ca6.jpg)

[开源协议介绍](https://github.com/marmotedu/geekbang-go/blob/master/开源协议介绍.md)

#### 开源规范特点

- 第一，开源项目，应该有一个**高的单元覆盖率**。这样，一方面可以确保第三方开发者在开发完代码之后，能够很方便地对整个项目做详细的单元测试，另一方面也能保证提交代码的质量。

- 第二，要确保整个代码库和提交记录中，不能出现**内部IP、内部域名、密码、密钥**这类信息。否则，就会造成**敏感信息**外漏，可能会对我们的内部业务造成安全隐患。

- 第三，当我们的开源项目被别的开发者提交 pull request、issue、评论时，要**及时处理**，一方面可以确保项目不断被更新，另一方面也可以激发其他开发者贡献代码的积极性。

- 第四，好的开源项目，应该能够**持续地更新功能，修复Bug**。对于一些已经结项、不维护的开源项目，需要及时地对项目进行归档，并在项目描述中加以说明。

[开源规范详细列表](https://github.com/marmotedu/geekbang-go/blob/master/开源规范详细列表.md)

> 提醒：
>
> 第一件，如果有条件，你可以宣传、运营开源项目，让更多的人知道、使用、贡献代码。比如，你可以在掘金、简书等平台发表文章，也可以创建 QQ、微信交流群等，都是不错的方式。
>
> 第二件，如果你英文好、有时间，文档最好有中英文 2 份，优先使用英文，让来自全球的开发者都能了解、使用和参与你的项目。

### 4.3 文档规范

文档属于**软件交付**的一个重要组成部分，没有文档的项目很难理解、部署和使用。

#### README规范

README模板:

```markdown
# 项目名称

<!-- 写一段简短的话描述项目 -->

## 功能特性

<!-- 描述该项目的核心功能点 -->

## 软件架构(可选)

<!-- 可以描述下项目的架构 -->

## 快速开始

### 依赖检查

<!-- 描述该项目的依赖，比如依赖的包、工具或者其他任何依赖项 -->

### 构建

<!-- 描述如何构建该项目 -->

### 运行

<!-- 描述如何运行该项目 -->

## 使用指南

<!-- 描述如何使用该项目 -->

## 如何贡献

<!-- 告诉其他开发者如果给该项目贡献源码 -->

## 社区(可选)

<!-- 如果有需要可以介绍一些社区相关的内容 -->

## 关于作者

<!-- 这里写上项目作者 -->

## 谁在用(可选)

<!-- 可以列出使用本项目的其他有影响力的项目，算是给项目打个广告吧 -->

## 许可证

<!-- 这里链接上该项目的开源许可证 -->
```

[在线的README生成工具](readme.so)

#### 项目文档规范

项目文档包括一切**需要文档化的内容**，通常集中放在`/docs`目录下。

好的文档规范有 2 个优点：易读和可以快速定位文档。

不同项目有不同的文档需求，在制定文档规范时，你可以考虑包含两类文档。

- **开发文档**：用来说明项目的==开发流程==，比如**如何搭建开发环境、构建二进制文件、测试、部署**等。
- **用户文档**：软件的==使用文档==，对象一般是软件的使用者，内容可根据需要添加。比如，可以包括**API文档、SDK文档、安装文档、功能介绍文档、最佳实践、操作指南、常见问题**等。

为了方便全球开发者和用户使用，开发文档和用户文档，可以预先规划好英文和中文 2 个版本。

实战项目的文档目录结构：

```
docs
├── devel                            # 开发文档，可以提前规划好，英文版文档和中文版文档
│   ├── en-US/                       # 英文版文档，可以根据需要组织文件结构
│   └── zh-CN                        # 中文版文档，可以根据需要组织文件结构
│       └── development.md           # 开发手册，可以说明如何编译、构建、运行项目
├── guide                            # 用户文档
│   ├── en-US/                       # 英文版文档，可以根据需要组织文件结构
│   └── zh-CN                        # 中文版文档，可以根据需要组织文件结构
│       ├── api/                     # API文档
│       ├── best-practice            # 最佳实践，存放一些比较重要的实践文章
│       │   └── authorization.md
│       ├── faq                      # 常见问题
│       │   ├── iam-apiserver
│       │   └── installation
│       ├── installation             # 安装文档
│       │   └── installation.md
│       ├── introduction/            # 产品介绍文档
│       ├── operation-guide          # 操作指南，里面可以根据RESTful资源再划分为更细的子目录，用来存放系统核心/全部功能的操作手册
│       │   ├── policy.md
│       │   ├── secret.md
│       │   └── user.md
│       ├── quickstart               # 快速入门
│       │   └── quickstart.md
│       ├── README.md                # 用户文档入口文件
│       └── sdk                      # SDK文档
│           └── golang.md
└── images                           # 图片存放目录
    └── 部署架构v1.png
```

#### API接口文档规范

接口文档又称为API文档，一般由**后台开发人员**编写，用来描述组件提供的 API 接口，以及如何调用这些 API 接口。

在项目初期，接口文档可以**解耦前后端**，让前后端并行开发：前端只需要按照接口文档实现调用逻辑，后端只需要按照接口文档提供功能。

在项目后期，接口文档可以提供给使用者，不仅可以降低组件的使用门槛，还能够减少沟通成本。

有**固定格式、结构清晰、内容完善**的接口文档。

接口文档有四种编写方式：编写Word格式文档、借助工具编写、通过注释生成和编写Markdown格式文档。

![](images/image-20240718200710843.png)

通过注释生成和编写 Markdown 格式文档这 2 种方式用得最多。本项目采用编写 Markdown 格式文档的方式，原因如下：

- 相比通过注释生成的方式，编写 Markdown 格式的接口文档，能表达**更丰富的内容和格式，不需要在代码中添加大量注释**。
- 相比 Word 格式的文档，Markdown 格式文档占用的**空间更小**，能够跟随代码仓库一起发布，方便 API 文档的分发和查找。
- 相比在线 API 文档编写工具，Markdown 格式的文档免去了第三方平台依赖和网络的限制。



一个规范的API接口文档，通常需要包含一个完整的 **API接口介绍文档、API接口变更历史文档、通用说明、数据结构说明、错误码描述和API接口使用文档**。API接口使用文档中需要包含**接口描述、请求方法、请求参数、输出参数和请求示例**。

接口文档拆分为以下几个 Markdown 文件，并存放在目录 [docs/guide/zh-CN/api](https://github.com/marmotedu/iam/tree/v1.0.0/docs/guide/zh-CN/api) 中：

- [README.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/README.md) ：API 接口介绍文档，会分类介绍 IAM 支持的 API 接口，并会存放相关 API 接口文档的链接，方便开发者查看。
- [CHANGELOG.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/CHANGELOG.md) ：API 接口文档变更历史，方便进行历史回溯，也可以使调用者决定是否进行功能更新和版本更新。
- [generic.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/generic.md) ：用来说明通用的请求参数、返回参数、认证方法和请求方法等。
- [struct.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/struct.md) ：用来列出接口文档中使用的数据结构。这些数据结构可能被多个 API 接口使用，会在 user.md、secret.md、policy.md 文件中被引用。
- [user.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/user.md) 、 [secret.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/secret.md) 、 [policy.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/policy.md) ：API 接口文档，相同 REST 资源的接口会存放在一个文件中，以 REST 资源名命名文档名。
- [error_code.md](https://github.com/marmotedu/iam/blob/master/docs/guide/zh-CN/api/error_code_generated.md) ：错误码描述，通过程序自动生成。

以`user.md`接口文档为例， 记录了用户相关的接口，每个接口按顺序排列包含5部分：

- **接口描述**：描述接口实现了什么功能。
- **请求方法**：接口的请求方法，格式为 `HTTP 方法 请求路径`，例如 `POST /v1/users`。在 **通用说明**中的**请求方法**部分，会说明接口的请求协议和请求地址。
- **输入参数**：接口的输入字段，它又分为 Header 参数、Query 参数、Body 参数、Path 参数。每个字段通过：**参数名称**、**必选**、**类型** 和 **描述** 4 个属性来描述。如果参数有限制或者默认值，可以在描述部分注明。
- **输出参数**：接口的返回字段，每个字段通过 **参数名称**、**类型** 和 **描述** 3 个属性来描述。
- **请求示例**：一个真实的 API 接口请求和返回示例。

### 4.4 版本规范

把所有组件都加入版本机制的好处：

- 一是通过版本号，我们可以很明确地知道组件是哪个版本，从而定位到该组件的功能和代码，方便我们定位问题。
- 二是发布组件时携带版本号，可以让使用者知道目前的项目进度，以及使用版本和上一个版本的功能差别等。

目前业界主流的版本规范是语义化版本规范。

#### 什么是语义化版本规范（SemVer）？

==语义化版本规范（SemVer，Semantic Versioning）==是 GitHub 起草的一个具有指导意义的、统一的版本号表示规范。它规定了版本号的表示、增加和比较方式，以及不同版本号代表的含义。

`主版本号.次版本号.修订号（X.Y.Z）`，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。

版本号可按以下规则递增：

- 主版本号（MAJOR）：当做了不兼容的 API 修改。
- 次版本号（MINOR）：当做了向下兼容的功能性新增及修改。这里有个不成文的约定，偶数为稳定版本，奇数为开发版本。
- 修订号（PATCH）：当做了向下兼容的问题修正。

还有把**先行版本号**（Pre-release）和**版本编译元数据**，作为延伸加到了`主版本号.次版本号.修订号`的后面，格式为 `X.Y.Z[-先行版本号][+版本编译元数据]`：

![](images/image-20240719001307066.png)

先行版本号意味着，该版本不稳定，可能存在兼容性问题，格式为：`X.Y.Z-[一连串以句点分隔的标识符]` ，比如：

```
1.0.0-alpha
1.0.0-alpha.1
1.0.0-0.3.7
1.0.0-x.7.z.92
```

编译版本号，一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制。比如：

```
1.0.0-alpha+001
1.0.0+20130313144700
1.0.0-beta+exp.sha.5114f85
```

> 注意，**先行版本号和编译版本号只能是字母、数字，且不可以有空格**。

#### 语义化版本控制规范

[详细语义化版本规范](https://semver.org/lang/zh-CN/)

- 标记版本号的软件发行后，禁止改变该版本软件的内容，任何修改都必须以新版本发行。
- 主版本号为零（0.y.z）的软件处于==开发初始阶段==，一切都可能随时被改变，这样的公共 API 不应该被视为稳定版。1.0.0 的版本号被界定为第一个稳定版本，之后的所有版本号更新都基于该版本进行修改。
- 修订号 Z（x.y.Z | x > 0）必须在只做了向下兼容的==修正==时才递增，这里的修正其实就是**Bug修复**。
- 次版本号 Y（x.Y.z | x > 0）必须在有向下兼容的==新功能==出现时递增，在任何公共 API 的功能被标记为弃用时也必须递增，当有改进时也可以递增。其中可以包括修订级别的改变。每当次版本号递增时，修订号必须归零。
- 主版本号 X（X.y.z | X > 0）必须在有任何==不兼容的修改==被加入公共API时递增。其中可以包括次版本号及修订级别的改变。**每当主版本号递增时，次版本号和修订号必须归零**。

#### 如何确定版本号？

几个经验：

第一，在实际开发的时候，我建议你使用 `0.1.0` 作为第一个开发版本号，并在后续的每次发行时递增次版本号。

第二，当我们的版本是一个稳定的版本，并且第一次对外发布时，版本号可以定为 `1.0.0`。

第三，当我们严格按照 Angular commit message 规范提交代码时，版本号可以这么来确定：

- `fix` 类型的 commit 可以将修订号+1。
- `feat` 类型的 commit 可以将次版本号+1。
- 带有 `BREAKING CHANGE` 的 commit 可以将主版本号+1。

## 5 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？

好的 Commit Message作用：

- **清晰地知道每个 commit 的变更内容**。
-  **进行过滤查找**，比如只查找某个版本新增的功能：`git log --oneline --grep "^feat|^fix|^perf"`。
- 基于规范化的 Commit Message **生成 Change Log**。
- 依据某些类型的 Commit Message **触发构建或者发布流程**，比如当 type 类型为 feat、fix 时才触发 CI 流程。

- **确定语义化版本的版本号**。比如 `fix` 类型可以映射为 PATCH 版本，`feat` 类型可以映射为 MINOR 版本。带有 `BREAKING CHANGE` 的 commit，可以映射为 MAJOR 版本。



Commit Message 的规范有哪些？
- Header
- Body
- Footer
- Revert Commit

Commit 相关的 3 个重要内容
- 提交频率
- 合并提交
  - git rebase 命令介绍
  - 合并提交操作示例
- 修改 Commit Message
  - git commit –amend：修改最近一次 commit 的 message
  - git rebase -i：修改某次 commit 的 message

Commit Message 规范自动化







6 目录结构设计：如何组织一个可维护、可扩展的代码目录？

7 工作流设计：如何设计合理的多人开发模式？

8 研发流程设计（上）：如何设计 Go 项目的开发流程？

9 研发流程设计（下）：如何管理应用的生命周期？

10 设计方法：怎么写出优雅的 Go 项目？

11 设计模式：Go常用设计模式概述

# 二、基础功能设计或开发

12 API 风格（上）：如何设计RESTful API？

13 API 风格（下）：RPC API介绍

14 项目管理：如何编写高质量的Makefile？

15 研发流程实战：IAM项目是如何进行研发流程管理的？

16 代码检查：如何进行静态代码检查？

17 API 文档：如何生成 Swagger API 文档 ？

18 错误处理（上）：如何设计一套科学的错误码？

19 错误处理（下）：如何设计错误包？

20 日志处理（上）：如何设计日志包并记录日志？

21 日志处理（下）：手把手教你从 0 编写一个日志包

22 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍

23 应用构建实战：如何构建一个优秀的企业应用框架？



# 三、服务开发

24 Web 服务：Web 服务核心功能有哪些，如何实现？

25 认证机制：应用程序如何进行访问认证？

26 IAM项目是如何设计和实现访问认证功能的？

27 权限模型：5大权限模型是如何进行资源授权的？

28 控制流（上）：通过iam-apiserver设计，看Web服务的构建

29 控制流（下）：iam-apiserver服务核心功能实现讲解


30 ORM：CURD 神器 GORM 包介绍及实战

31 数据流：通过iam-authz-server设计，看数据流服务的设计

32 数据处理：如何高效处理应用程序产生的数据？

33 SDK 设计（上）：如何设计出一个优秀的 Go SDK？

34 SDK 设计（下）：IAM项目Go SDK设计和实现

35 效率神器：如何设计和实现一个命令行客户端工具？



# 四、服务测试

36 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？

37 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍

38 性能分析（上）：如何分析 Go 语言代码的性能？

39 性能分析（下）：API Server性能测试和调优实战

# 五、服务部署

40 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍

41 软件部署实战（中）：IAM 系统生产环境部署实战

42 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战

43 技术演进（上）：虚拟化技术演进之路

44 技术演进（下）：软件架构和应用生命周期技术演进之路

45 基于Kubernetes的云原生架构设计

46 如何制作Docker镜像？

47 如何编写Kubernetes资源定义文件？

48 IAM 容器化部署实战

49 服务编排（上）：Helm服务编排基础知识

50 服务编排（下）：基于Helm的服务编排部署实战

51 基于 GitHub Actions 的 CI 实战